<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>redis | jhj-coding</title><meta name="author" content="jhj,hnjzjhj@163.com"><meta name="copyright" content="jhj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="RedisRedis 基础什么是 Redis？Redisopen in new windowhttps:&#x2F;&#x2F;redis.io&#x2F; 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。 为了满足不同的业务场景，Redis 内置了多种数据类型实现（比">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://example.com/post/7b25d017.html">
<meta property="og:site_name" content="jhj-coding">
<meta property="og:description" content="RedisRedis 基础什么是 Redis？Redisopen in new windowhttps:&#x2F;&#x2F;redis.io&#x2F; 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。 为了满足不同的业务场景，Redis 内置了多种数据类型实现（比">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/jhj-coding/my-typora-picgo/raw/50195fa8344b061b78a2d7aaafcc2b9d8e7956ad/img/f63f1c575e3c48d9a3f7e4ba9bd460d2.png">
<meta property="article:published_time" content="2023-10-10T10:00:00.000Z">
<meta property="article:modified_time" content="2024-03-14T12:40:16.764Z">
<meta property="article:author" content="jhj">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/jhj-coding/my-typora-picgo/raw/50195fa8344b061b78a2d7aaafcc2b9d8e7956ad/img/f63f1c575e3c48d9a3f7e4ba9bd460d2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/7b25d017.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"MN792LJJVS","apiKey":"e946d312db0afe9b3f7d3e71f5f7585b","indexName":"jhj","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: jhj","link":"链接: ","source":"来源: jhj-coding","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-14 20:40:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4464920_sugj9c5f13.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">185</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/jhj-coding/my-typora-picgo/raw/50195fa8344b061b78a2d7aaafcc2b9d8e7956ad/img/f63f1c575e3c48d9a3f7e4ba9bd460d2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="jhj-coding"><span class="site-name">jhj-coding</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-10T10:00:00.000Z" title="发表于 2023-10-10 18:00:00">2023-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-14T12:40:16.764Z" title="更新于 2024-03-14 20:40:16">2024-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/sql/">sql</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h3><h4 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h4><p>Redisopen in new window<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a> 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>
<p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p>
<h4 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h4><p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p>
<ol>
<li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li>
<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li>
<li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li>
</ol>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039057.png" alt="why-redis-so-fast"></p>
<h4 id="分布式缓存常见的技术选型方案有哪些？"><a href="#分布式缓存常见的技术选型方案有哪些？" class="headerlink" title="分布式缓存常见的技术选型方案有哪些？"></a>分布式缓存常见的技术选型方案有哪些？</h4><p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
<h4 id="说一下-Redis-和-Memcached-的区别和共同点"><a href="#说一下-Redis-和-Memcached-的区别和共同点" class="headerlink" title="说一下 Redis 和 Memcached 的区别和共同点"></a>说一下 Redis 和 Memcached 的区别和共同点</h4><p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>
<p><strong>共同点</strong>：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 针对网络数据的读写引入了多线程）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ol>
<h4 id="为什么要用-Redis-为什么要用缓存？"><a href="#为什么要用-Redis-为什么要用缓存？" class="headerlink" title="为什么要用 Redis&#x2F;为什么要用缓存？"></a>为什么要用 Redis&#x2F;为什么要用缓存？</h4><p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p>
<p><strong>1、高性能</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p><strong>2、高并发</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。<br>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<h3 id="3种常用的缓存读写策略详解"><a href="#3种常用的缓存读写策略详解" class="headerlink" title="3种常用的缓存读写策略详解"></a>3种常用的缓存读写策略详解</h3><h4 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h4><p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
<p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</p>
<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>
<p><strong>写</strong>：</p>
<ul>
<li>先更新 db</li>
<li>然后直接删除 cache 。</li>
</ul>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039058.png" alt="img"></p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039059.png" alt="img"></p>
<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong>”</p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p>
<p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。</p>
<p>这个过程可以简单描述为：<br>请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>
<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”</p>
<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p>
<p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。</p>
<p>这个过程可以简单描述为：<br>请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p>
<p><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入 cache 中。</p>
<p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新 cache 的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h4 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h4><p>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039060.png" alt="img"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039061.png" alt="img"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h4 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h4><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<h3 id="Redis-应用"><a href="#Redis-应用" class="headerlink" title="Redis 应用"></a>Redis 应用</h3><h4 id="Redis-除了做缓存，还能做什么？"><a href="#Redis-除了做缓存，还能做什么？" class="headerlink" title="Redis 除了做缓存，还能做什么？"></a>Redis 除了做缓存，还能做什么？</h4><ul>
<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：分布式锁详解open in new window<a target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-lock.html">https://javaguide.cn/distributed-system/distributed-lock.html</a> 。</li>
<li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA%E3%80%82">https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA。</a></li>
<li><strong>消息队列</strong>：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 sorted set 实现的）。</li>
<li><strong>分布式 Session</strong> ：利用 string 或者 hash 保存 Session 数据，所有的服务器都可以访问。</li>
<li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
</ul>
<h4 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="Redis 可以做消息队列么？"></a>Redis 可以做消息队列么？</h4><p>先说结论：可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</p>
<p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p>
<p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 生产者生产消息</span><br><span class="line">&gt; <span class="variable constant_">RPUSH</span> myList msg1 msg2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">&gt; <span class="variable constant_">RPUSH</span> myList msg3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"># 消费者消费消息</span><br><span class="line">&gt; <span class="variable constant_">LPOP</span> myList</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>
<p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 超时时间为 10s</span><br><span class="line"># 如果有数据立刻返回，否则最多等待<span class="number">10</span>秒</span><br><span class="line">&gt; <span class="variable constant_">BRPOP</span> myList <span class="number">10</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p>
<p><strong>Redis 2.0 引入了发布订阅 (pub&#x2F;sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039062.png" alt="Redis 发布订阅 (pub/sub) 功能">Redis 发布订阅 (pub&#x2F;sub) 功能</p>
<p>pub&#x2F;sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p>
<p>pub&#x2F;sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p>
<ul>
<li>发布者通过</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUBLISH</span></span><br></pre></td></tr></table></figure>
<p>投递消息给指定 channel。</p>
<ul>
<li>订阅者通过</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SUBSCRIBE</span></span><br></pre></td></tr></table></figure>
<p>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</p>
<p>我们这里启动 3 个 Redis 客户端来简单演示一下：</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039063.png" alt="pub/sub 实现消息队列演示">pub&#x2F;sub 实现消息队列演示</p>
<p>pub&#x2F;sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p>
<p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p>
<ul>
<li>发布 &#x2F; 订阅模式</li>
<li>按照消费者组进行消费</li>
<li>消息持久化（ RDB 和 AOF）</li>
</ul>
<p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。而且，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>
<p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>
<h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><h4 id="Redis-5-种基本数据结构详解"><a href="#Redis-5-种基本数据结构详解" class="headerlink" title="Redis 5 种基本数据结构详解"></a>Redis 5 种基本数据结构详解</h4><p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Dict（哈希表&#x2F;字典）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>
<p>Redis 基本数据结构的底层数据结构实现如下：<br>String List Hash Set Zset SDS LinkedList&#x2F;ZipList&#x2F;QuickList Dict、ZipList Dict、Intset ZipList、SkipList</p>
<p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。从 Redis 7.0 开始， ZipList 被 ListPack 取代。</p>
<h4 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h4><p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p>
<p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039064.png" alt="img"></p>
<p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p>常用命令</p>
<p>命令 介绍 SET key value 设置指定 key 的值 SETNX key value 只有在 key 不存在时设置 key 的值 GET key 获取指定 key 的值 MSET key1 value1 key2 value2 … 设置一个或多个指定 key 的值 MGET key1 key2 … 获取一个或多个指定 key 的值 STRLEN key 返回 key 所储存的字符串值的长度 INCR key 将 key 中储存的数字值增一 DECR key 将 key 中储存的数字值减一 EXISTS key 判断指定 key 是否存在 DEL key（通用） 删除指定的 key EXPIRE key seconds（通用） 给指定 key 设置过期时间</p>
<p><strong>基本操作</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">SET</span> key value</span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">GET</span> key</span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">EXISTS</span> key</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">STRLEN</span> key</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line">&gt; <span class="variable constant_">DEL</span> key</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">GET</span> key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>批量设置</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">MSET</span> key1 value1 key2 value2</span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">MGET</span> key1 key2 # 批量获取多个 key 对应的 value</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">SET</span> number <span class="number">1</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">INCR</span> number # 将 key 中储存的数字值增一</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">&gt; <span class="variable constant_">GET</span> number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">DECR</span> number # 将 key 中储存的数字值减一</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">GET</span> number</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>设置过期时间（默认为永不过期）</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">EXPIRE</span> key <span class="number">60</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">SETEX</span> key <span class="number">60</span> value # 设置值并设置过期时间</span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">TTL</span> key</span><br><span class="line">(integer) <span class="number">56</span></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><strong>需要存储常规数据的场景</strong></p>
<ul>
<li>举例：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SET</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span></span><br></pre></td></tr></table></figure>
<p>。</p>
<p><strong>需要计数的场景</strong></p>
<ul>
<li>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SET</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">INCR</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DECR</span></span><br></pre></td></tr></table></figure>
<p>。</p>
<p><strong>分布式锁</strong></p>
<p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p>
<h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h4><p>介绍</p>
<p>Redis 中的 List 其实就是链表数据结构的实现。许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039065.png" alt="img"></p>
<p>常用命令</p>
<p>命令 介绍 RPUSH key value1 value2 … 在指定列表的尾部（右边）添加一个或多个元素 LPUSH key value1 value2 … 在指定列表的头部（左边）添加一个或多个元素 LSET key index value 将指定列表索引 index 位置的值设置为 value LPOP key 移除并获取指定列表的第一个元素(最左边) RPOP key 移除并获取指定列表的最后一个元素(最右边) LLEN key 获取列表元素数量 LRANGE key start end 获取列表 start 和 end 之间 的元素</p>
<p>**通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">RPUSH</span>/<span class="variable constant_">LPOP</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">LPUSH</span>/<span class="variable constant_">RPOP</span></span><br></pre></td></tr></table></figure>
<p>实现队列**：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">RPUSH</span> myList value1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">RPUSH</span> myList value2 value3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">&gt; <span class="variable constant_">LPOP</span> myList</span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">LRANGE</span> myList <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">LRANGE</span> myList <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p>**通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">RPUSH</span>/<span class="variable constant_">RPOP</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">LPUSH</span>/<span class="variable constant_">LPOP</span></span><br></pre></td></tr></table></figure>
<p>实现栈**：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">RPUSH</span> myList2 value1 value2 value3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">&gt; <span class="variable constant_">RPOP</span> myList2 # 将 list的最右边的元素取出</span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p>我专门画了一个图方便大家理解 <code>RPUSH</code> , <code>LPOP</code> , <code>lpush</code> , <code>RPOP</code> 命令：</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039066.png" alt="img"></p>
<p>**通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">LRANGE</span></span><br></pre></td></tr></table></figure>
<p>查看对应下标范围的列表元素**：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">RPUSH</span> myList value1 value2 value3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">&gt; <span class="variable constant_">LRANGE</span> myList <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">LRANGE</span> myList <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>LRANGE</code> 命令，你可以基于 List 实现分页查询，性能非常高！</p>
<p>**通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">LLEN</span></span><br></pre></td></tr></table></figure>
<p>查看链表长度**：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">LLEN</span> myList</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><strong>信息流展示</strong></p>
<ul>
<li>举例：最新文章、最新动态。</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">LPUSH</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">LRANGE</span></span><br></pre></td></tr></table></figure>
<p>。</p>
<p><strong>消息队列</strong></p>
<p>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>
<p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p>
<h4 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h4><p>介绍</p>
<p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>
<p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039067.png" alt="img"></p>
<p>常用命令</p>
<p>命令 介绍 HSET key field value 设置指定哈希表中指定字段的值 HSETNX key field value 只有指定字段不存在时设置指定字段的值 HMSET key field1 value1 field2 value2 … 同时将一个或多个 field-value (域-值)对设置到指定哈希表中 HGET key field 获取指定哈希表中指定字段的值 HMGET key field1 field2 … 获取指定哈希表中一个或者多个指定字段的值 HGETALL key 获取指定哈希表中所有的键值对 HEXISTS key field 查看指定哈希表中指定的字段是否存在 HDEL key field1 field2 … 删除一个或多个哈希表字段 HLEN key 获取指定哈希表中字段的数量 HINCRBY key field increment 对指定哈希中的指定字段做运算操作（正数为加，负数为减）</p>
<p><strong>模拟对象数据存储</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">HMSET</span> userInfoKey name <span class="string">&quot;guide&quot;</span> description <span class="string">&quot;dev&quot;</span> age <span class="number">24</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">HEXISTS</span> userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">HGET</span> userInfoKey name # 获取存储在哈希表中指定字段的值。</span><br><span class="line"><span class="string">&quot;guide&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">HGET</span> userInfoKey age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">HGETALL</span> userInfoKey # 获取在哈希表中指定 key 的所有字段和值</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;guide&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;description&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;dev&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;24&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">HSET</span> userInfoKey name <span class="string">&quot;GuideGeGe&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">HGET</span> userInfoKey name</span><br><span class="line"><span class="string">&quot;GuideGeGe&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">HINCRBY</span> userInfoKey age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">26</span></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><strong>对象数据存储场景</strong></p>
<ul>
<li>举例：用户信息、商品信息、文章信息、购物车信息。</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HSET</span></span><br></pre></td></tr></table></figure>
<p>（设置单个字段的值）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HMSET</span></span><br></pre></td></tr></table></figure>
<p>（设置多个字段的值）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HGET</span></span><br></pre></td></tr></table></figure>
<p>（获取单个字段的值）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HMGET</span></span><br></pre></td></tr></table></figure>
<p>（获取多个字段的值）。</p>
<h4 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h4><p>介绍</p>
<p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>
<p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039068.png" alt="img"></p>
<p>常用命令</p>
<p>命令 介绍 SADD key member1 member2 … 向指定集合添加一个或多个元素 SMEMBERS key 获取指定集合中的所有元素 SCARD key 获取指定集合的元素数量 SISMEMBER key member 判断指定元素是否在指定集合中 SINTER key1 key2 … 获取给定所有集合的交集 SINTERSTORE destination key1 key2 … 将给定所有集合的交集存储在 destination 中 SUNION key1 key2 … 获取给定所有集合的并集 SUNIONSTORE destination key1 key2 … 将给定所有集合的并集存储在 destination 中 SDIFF key1 key2 … 获取给定所有集合的差集 SDIFFSTORE destination key1 key2 … 将给定所有集合的差集存储在 destination 中 SPOP key count 随机移除并获取指定集合中一个或多个元素 SRANDMEMBER key count 随机获取指定集合中指定数量的元素</p>
<p><strong>基本操作</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">SADD</span> mySet value1 value2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">&gt; <span class="variable constant_">SADD</span> mySet value1 # 不允许有重复元素，因此添加失败</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">&gt; <span class="variable constant_">SMEMBERS</span> mySet</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">SCARD</span> mySet</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">&gt; <span class="variable constant_">SISMEMBER</span> mySet value1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">SADD</span> mySet2 value2 value3</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>mySet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">value1</span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value2</span><br></pre></td></tr></table></figure>
<p>。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>mySet2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">：</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">value2</span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value3</span><br></pre></td></tr></table></figure>
<p>。</p>
<p><strong>求交集</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">SINTERSTORE</span> mySet3 mySet mySet2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">SMEMBERS</span> mySet3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>求并集</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">SUNION</span> mySet mySet2</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>求差集</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">SDIFF</span> mySet mySet2 # 差集是由所有属于 mySet 但不属于 A 的元素组成的集合</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><strong>需要存放的数据不能重复的场景</strong></p>
<ul>
<li>举例：网站 UV 统计（数据量巨大的场景还是</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HyperLogLog</span></span><br></pre></td></tr></table></figure>
<p>更适合一些）、文章点赞、动态点赞等场景。</p>
<ul>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SCARD</span></span><br></pre></td></tr></table></figure>
<p>（获取集合数量） 。</p>
<p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p>
<ul>
<li>举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SINTER</span></span><br></pre></td></tr></table></figure>
<p>（交集）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SINTERSTORE</span></span><br></pre></td></tr></table></figure>
<p>（交集）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SUNION</span></span><br></pre></td></tr></table></figure>
<p>（并集）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SUNIONSTORE</span></span><br></pre></td></tr></table></figure>
<p>（并集）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SDIFF</span></span><br></pre></td></tr></table></figure>
<p>（差集）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SDIFFSTORE</span></span><br></pre></td></tr></table></figure>
<p>（差集）。</p>
<p><strong>需要随机获取数据源中的元素的场景</strong></p>
<ul>
<li>举例：抽奖系统、随机点名等场景。</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SPOP</span></span><br></pre></td></tr></table></figure>
<p>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SRANDMEMBER</span></span><br></pre></td></tr></table></figure>
<p>（随机获取集合中的元素，适合允许重复中奖的场景）。</p>
<h4 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h4><p>介绍</p>
<p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039069.png" alt="img"></p>
<p>常用命令</p>
<p>命令 介绍 ZADD key score1 member1 score2 member2 … 向指定有序集合添加一个或多个元素 ZCARD KEY 获取指定有序集合的元素数量 ZSCORE key member 获取指定有序集合中指定元素的 score 值 ZINTERSTORE destination numkeys key1 key2 … 将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量 ZUNIONSTORE destination numkeys key1 key2 … 求并集，其它和 ZINTERSTORE 类似 ZDIFFSTORE destination numkeys key1 key2 … 求差集，其它和 ZINTERSTORE 类似 ZRANGE key start end 获取指定有序集合 start 和 end 之间的元素（score 从低到高） ZREVRANGE key start end 获取指定有序集合 start 和 end 之间的元素（score 从高到底） ZREVRANK key member 获取指定有序集合中指定元素的排名(score 从大到小排序)</p>
<p><strong>基本操作</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">ZADD</span> myZset <span class="number">2.0</span> value1 <span class="number">1.0</span> value2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">&gt; <span class="variable constant_">ZCARD</span> myZset</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; <span class="variable constant_">ZSCORE</span> myZset value1</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line">&gt; <span class="variable constant_">ZRANGE</span> myZset <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">ZREVRANGE</span> myZset <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">ZADD</span> myZset2 <span class="number">4.0</span> value2 <span class="number">3.0</span> value3</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>myZset</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">value1</span><br></pre></td></tr></table></figure>
<p>(2.0)、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value2</span><br></pre></td></tr></table></figure>
<p>(1.0) 。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>myZset2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">：</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">value2</span><br></pre></td></tr></table></figure>
<p>（4.0）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value3</span><br></pre></td></tr></table></figure>
<p>(3.0) 。</p>
<p><strong>获取指定元素的排名</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">ZREVRANK</span> myZset value1</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; <span class="variable constant_">ZREVRANK</span> myZset value2</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>求交集</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">ZINTERSTORE</span> myZset3 <span class="number">2</span> myZset myZset2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">ZRANGE</span> myZset3 <span class="number">0</span> <span class="number">1</span> <span class="variable constant_">WITHSCORES</span></span><br><span class="line">value2</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>求并集</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">ZUNIONSTORE</span> myZset4 <span class="number">2</span> myZset myZset2</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; <span class="variable constant_">ZRANGE</span> myZset4 <span class="number">0</span> <span class="number">2</span> <span class="variable constant_">WITHSCORES</span></span><br><span class="line">value1</span><br><span class="line"><span class="number">2</span></span><br><span class="line">value3</span><br><span class="line"><span class="number">3</span></span><br><span class="line">value2</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>求差集</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">ZDIFF</span> <span class="number">2</span> myZset myZset2 <span class="variable constant_">WITHSCORES</span></span><br><span class="line">value1</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>
<p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p>
<ul>
<li>举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">ZRANGE</span></span><br></pre></td></tr></table></figure>
<p>(从小到大排序)、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">ZREVRANGE</span></span><br></pre></td></tr></table></figure>
<p>（从大到小排序）、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">ZREVRANK</span></span><br></pre></td></tr></table></figure>
<p>(指定元素排名)。</p>
<h4 id="Redis-3-种特殊数据结构详解"><a href="#Redis-3-种特殊数据结构详解" class="headerlink" title="Redis 3 种特殊数据结构详解"></a>Redis 3 种特殊数据结构详解</h4><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p>介绍</p>
<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>
<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039070.png" alt="img"></p>
<p>常用命令</p>
<p>命令 介绍 SETBIT key offset value 设置指定 offset 位置的值 GETBIT key offset 获取指定 offset 位置的值 BITCOUNT key start end 获取 start 和 end 之前值为 1 的元素个数 BITOP operation destkey key1 key2 … 对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</p>
<p><strong>Bitmap 基本操作演示</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="variable constant_">SETBIT</span> 会返回之前位的值（默认是 <span class="number">0</span>）这里会生成 <span class="number">7</span> 个位</span><br><span class="line">&gt; <span class="variable constant_">SETBIT</span> mykey <span class="number">7</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">&gt; <span class="variable constant_">SETBIT</span> mykey <span class="number">7</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">GETBIT</span> mykey <span class="number">7</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">&gt; <span class="variable constant_">SETBIT</span> mykey <span class="number">6</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">&gt; <span class="variable constant_">SETBIT</span> mykey <span class="number">8</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"># 通过 bitcount 统计被被设置为 <span class="number">1</span> 的位的数量。</span><br><span class="line">&gt; <span class="variable constant_">BITCOUNT</span> mykey</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><strong>需要保存状态信息（0&#x2F;1 即可表示）的场景</strong></p>
<ul>
<li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SETBIT</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GETBIT</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BITCOUNT</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BITOP</span></span><br></pre></td></tr></table></figure>
<p>。</p>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>介绍</p>
<p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>
<p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>
<ul>
<li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li>
<li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li>
</ul>
<p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039071.png" alt="img"></p>
<p>HyperLogLog 的使用非常简单，但原理非常复杂。</p>
<p>常用命令</p>
<p>HyperLogLog 相关的命令非常少，最常用的也就 3 个。<br>命令 介绍 PFADD key element1 element2 … 添加一个或多个元素到 HyperLogLog 中 PFCOUNT key1 key2 获取一个或者多个 HyperLogLog 的唯一计数。 PFMERGE destkey sourcekey1 sourcekey2 … 将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</p>
<p><strong>HyperLogLog 基本操作演示</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">PFADD</span> hll foo bar zap</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">PFADD</span> hll zap zap zap</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">&gt; <span class="variable constant_">PFADD</span> hll foo bar</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">&gt; <span class="variable constant_">PFCOUNT</span> hll</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">&gt; <span class="variable constant_">PFADD</span> some-other-hll <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">PFCOUNT</span> hll some-other-hll</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line">&gt; <span class="variable constant_">PFMERGE</span> desthll hll some-other-hll</span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line">&gt; <span class="variable constant_">PFCOUNT</span> desthll</span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p>
<ul>
<li>举例：热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、</li>
<li>相关命令：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PFADD</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PFCOUNT</span></span><br></pre></td></tr></table></figure>

<h4 id="Geospatial-index"><a href="#Geospatial-index" class="headerlink" title="Geospatial index"></a>Geospatial index</h4><p>介绍</p>
<p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p>
<p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039073.png" alt="img"></p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>命令 介绍 GEOADD key longitude1 latitude1 member1 … 添加一个或多个元素对应的经纬度信息到 GEO 中 GEOPOS key member1 member2 … 返回给定元素的经纬度信息 GEODIST key member1 member2 M&#x2F;KM&#x2F;FT&#x2F;MI 返回两个给定元素之间的距离 GEORADIUS key longitude latitude radius distance 获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数 GEORADIUSBYMEMBER key member radius distance 类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</p>
<p><strong>基本操作</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">GEOADD</span> personLocation <span class="number">116.33</span> <span class="number">39.89</span> user1 <span class="number">116.34</span> <span class="number">39.90</span> user2 <span class="number">116.35</span> <span class="number">39.88</span> user3</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; <span class="variable constant_">GEOPOS</span> personLocation user1</span><br><span class="line"><span class="number">116.3299986720085144</span></span><br><span class="line"><span class="number">39.89000061669732844</span></span><br><span class="line">&gt; <span class="variable constant_">GEODIST</span> personLocation user1 user2 km</span><br><span class="line"><span class="number">1.4018</span></span><br></pre></td></tr></table></figure>

<p>通过 Redis 可视化工具查看 <code>personLocation</code> ，果不其然，底层就是 Sorted Set。</p>
<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039074.png" alt="img"></p>
<p><strong>获取指定位置范围内的其他元素</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">GEORADIUS</span> personLocation <span class="number">116.33</span> <span class="number">39.87</span> <span class="number">3</span> km</span><br><span class="line">user3</span><br><span class="line">user1</span><br><span class="line">&gt; <span class="variable constant_">GEORADIUS</span> personLocation <span class="number">116.33</span> <span class="number">39.87</span> <span class="number">2</span> km</span><br><span class="line">&gt; <span class="variable constant_">GEORADIUS</span> personLocation <span class="number">116.33</span> <span class="number">39.87</span> <span class="number">5</span> km</span><br><span class="line">user3</span><br><span class="line">user1</span><br><span class="line">user2</span><br><span class="line">&gt; <span class="variable constant_">GEORADIUSBYMEMBER</span> personLocation user1 <span class="number">5</span> km</span><br><span class="line">user3</span><br><span class="line">user1</span><br><span class="line">user2</span><br><span class="line">&gt; <span class="variable constant_">GEORADIUSBYMEMBER</span> personLocation user1 <span class="number">2</span> km</span><br><span class="line">user1</span><br><span class="line">user2</span><br></pre></td></tr></table></figure>

<p><strong>移除元素</strong>：</p>
<p>GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">ZREM</span> personLocation user1</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">ZRANGE</span> personLocation <span class="number">0</span> -<span class="number">1</span></span><br><span class="line">user3</span><br><span class="line">user2</span><br><span class="line">&gt; <span class="variable constant_">ZSCORE</span> personLocation user2</span><br><span class="line"><span class="number">4069879562983946</span></span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><strong>需要管理使用地理空间数据的场景</strong></p>
<ul>
<li>举例：附近的人。</li>
<li>相关命令:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GEOADD</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GEORADIUS</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GEORADIUSBYMEMBER</span></span><br></pre></td></tr></table></figure>
<p>。</p>
<h4 id="Redis-常用的数据结构有哪些？"><a href="#Redis-常用的数据结构有哪些？" class="headerlink" title="Redis 常用的数据结构有哪些？"></a>Redis 常用的数据结构有哪些？</h4><ul>
<li><strong>5 种基础数据结构</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong>：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
<h4 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="String 的应用场景有哪些？"></a>String 的应用场景有哪些？</h4><p>String 是 Redis 中最简单同时也是最常用的一个数据结构。String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p>String 的常见应用场景如下：</p>
<ul>
<li>常规数据（比如 session、token、序列化后的对象、图片的路径）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SETNX</span> key value</span><br></pre></td></tr></table></figure>
<p>命令可以实现一个最简易的分布式锁)；</p>
<h4 id="String-还是-Hash-存储对象数据更好呢？"><a href="#String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="String 还是 Hash 存储对象数据更好呢？"></a>String 还是 Hash 存储对象数据更好呢？</h4><ul>
<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p>
<h4 id="String-的底层实现是什么？"><a href="#String-的底层实现是什么？" class="headerlink" title="String 的底层实现是什么？"></a>String 的底层实现是什么？</h4><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 SDSopen in new window<a target="_blank" rel="noopener" href="https://github.com/antirez/sds%EF%BC%88Simple">https://github.com/antirez/sds（Simple</a> Dynamic String，简单动态字符串） 来作为底层实现。</p>
<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p>
<p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。<br>类型 字节 位 sdshdr5 &lt; 1 &lt;8 sdshdr8 1 8 sdshdr16 2 16 sdshdr32 4 32 sdshdr64 8 64</p>
<p>对于后四种实现都包含了下面这 4 个属性：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>len</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：字符串的长度也就是已经使用的字节数</span><br><span class="line">* ```js </span><br><span class="line">alloc</span><br></pre></td></tr></table></figure>
<p>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>buf[]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：实际存储字符串的数组</span><br><span class="line">* ```js </span><br><span class="line">flags</span><br></pre></td></tr></table></figure>
<p>：低三位保存类型标志</p>
<p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol>
<li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li>
<li><strong>减少内存分配次数</strong>：为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>
<li><strong>二进制安全</strong>：C 语言中的字符串以空字符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</p>
<h4 id="购物车信息用-String-还是-Hash-存储更好呢"><a href="#购物车信息用-String-还是-Hash-存储更好呢" class="headerlink" title="购物车信息用 String 还是 Hash 存储更好呢?"></a>购物车信息用 String 还是 Hash 存储更好呢?</h4><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039075.png" alt="Hash维护简单的购物车信息"></p>
<p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>
<h4 id="使用-Redis-实现一个排行榜怎么做？"><a href="#使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="使用 Redis 实现一个排行榜怎么做？"></a>使用 Redis 实现一个排行榜怎么做？</h4><p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039076.png" alt="img"></p>
<h4 id="Set-的应用场景是什么？"><a href="#Set-的应用场景是什么？" class="headerlink" title="Set 的应用场景是什么？"></a>Set 的应用场景是什么？</h4><p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p>
<p>Set 的常见应用场景如下：</p>
<ul>
<li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HyperLogLog</span></span><br></pre></td></tr></table></figure>
<p>更适合一些）、文章点赞、动态点赞等等。</p>
<ul>
<li>需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li>
<li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li>
</ul>
<h4 id="使用-Set-实现抽奖系统怎么做？"><a href="#使用-Set-实现抽奖系统怎么做？" class="headerlink" title="使用 Set 实现抽奖系统怎么做？"></a>使用 Set 实现抽奖系统怎么做？</h4><p>如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>SADD key member1 member2 …</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：向指定集合添加一个或多个元素。</span><br><span class="line">* ```js </span><br><span class="line">SPOP key count</span><br></pre></td></tr></table></figure>
<p>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>SRANDMEMBER key count</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">: 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</span><br><span class="line"></span><br><span class="line">#### 使用 Bitmap 统计活跃用户怎么做？</span><br><span class="line"></span><br><span class="line">Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</span><br><span class="line"></span><br><span class="line">你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</span><br><span class="line"></span><br><span class="line">![img](../images/f3fd7684-5ceb-4226-b25f-e1a663e3ccfd.png)img</span><br><span class="line"></span><br><span class="line">如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</span><br><span class="line"></span><br><span class="line">初始化数据：</span><br><span class="line">```js </span><br><span class="line">&gt; SETBIT 20210308 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SETBIT 20210308 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SETBIT 20210309 1 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>统计 20210308~20210309 总活跃用户数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">BITOP</span> and desk1 <span class="number">20210308</span> <span class="number">20210309</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">BITCOUNT</span> desk1</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>统计 20210308~20210309 在线活跃用户数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">BITOP</span> or desk2 <span class="number">20210308</span> <span class="number">20210309</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">BITCOUNT</span> desk2</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-HyperLogLog-统计页面-UV-怎么做？"><a href="#使用-HyperLogLog-统计页面-UV-怎么做？" class="headerlink" title="使用 HyperLogLog 统计页面 UV 怎么做？"></a>使用 HyperLogLog 统计页面 UV 怎么做？</h4><p>使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>PFADD key element1 element2 …</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：添加一个或多个元素到 HyperLogLog 中。</span><br><span class="line">* ```js </span><br><span class="line">PFCOUNT key1 key2</span><br></pre></td></tr></table></figure>
<p>：获取一个或者多个 HyperLogLog 的唯一计数。</p>
<p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PFADD</span> <span class="attr">PAGE_1</span>:<span class="variable constant_">UV</span> <span class="title class_">USER1</span> <span class="title class_">USER2</span> ...... <span class="title class_">USERn</span></span><br></pre></td></tr></table></figure>

<p>2、统计指定页面的 UV。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PFCOUNT</span> <span class="attr">PAGE_1</span>:<span class="variable constant_">UV</span></span><br></pre></td></tr></table></figure>

<h3 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h3><p>使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<h4 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h4><p>什么是 RDB 持久化？</p>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>           #在<span class="number">900</span>秒(<span class="number">15</span>分钟)之后，如果至少有<span class="number">1</span>个key发生变化，<span class="title class_">Redis</span>就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>          #在<span class="number">300</span>秒(<span class="number">5</span>分钟)之后，如果至少有<span class="number">10</span>个key发生变化，<span class="title class_">Redis</span>就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>        #在<span class="number">60</span>秒(<span class="number">1</span>分钟)之后，如果至少有<span class="number">10000</span>个key发生变化，<span class="title class_">Redis</span>就会自动触发bgsave命令创建快照。</span><br></pre></td></tr></table></figure>

<p>RDB 创建快照时会阻塞主线程吗？</p>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>save</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">: 同步保存操作，会阻塞 Redis 主线程；</span><br><span class="line">* ```js </span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure>
<p>: fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。<br>这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。</p>
<h4 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h4><h4 id="什么是-AOF-持久化？"><a href="#什么是-AOF-持久化？" class="headerlink" title="什么是 AOF 持久化？"></a>什么是 AOF 持久化？</h4><p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 <code>appendonly</code> 参数开启：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>
<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<h4 id="AOF-工作基本流程是怎样的？"><a href="#AOF-工作基本流程是怎样的？" class="headerlink" title="AOF 工作基本流程是怎样的？"></a>AOF 工作基本流程是怎样的？</h4><p>AOF 持久化功能的实现可以简单分为 5 步：</p>
<ol>
<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>
<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>函数（系统调用），</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</p>
<ol>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>策略）向硬盘做同步操作。这一步需要调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>函数（系统调用），</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>针对单个文件操作，对其进行强制硬盘同步，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>将阻塞直到写入磁盘完成后返回，保证了数据持久化。</p>
<ol>
<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。<br>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 <strong>系统调用（syscall）</strong>。</li>
</ol>
<p>这里对上面提到的一些 Linux 系统调用再做一遍解释：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>write</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</span><br><span class="line">* ```js </span><br><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</p>
<p>AOF 工作流程图如下：</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039077.png" alt="AOF 工作基本流程"></p>
<h4 id="AOF-持久化方式有哪些？"><a href="#AOF-持久化方式有哪些？" class="headerlink" title="AOF 持久化方式有哪些？"></a>AOF 持久化方式有哪些？</h4><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<p>1. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always</span><br></pre></td></tr></table></figure>
<p>：主线程调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>执行写操作后，后台线程（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof_fsync</span><br></pre></td></tr></table></figure>
<p>线程）立即会调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>函数同步 AOF 文件（刷盘），</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>完成后线程返回，这样会严重降低 Redis 的性能（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>）。</p>
<p>1. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>
<p>：主线程调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>执行写操作后立即返回，由后台线程（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof_fsync</span><br></pre></td></tr></table></figure>
<p>线程）每秒钟调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>函数（系统调用）同步一次 AOF 文件（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>间隔为 1 秒）</p>
<p>1. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync no</span><br></pre></td></tr></table></figure>
<p>：主线程调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>但不</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>的时机由操作系统决定）。</p>
<p>可以看出：**这 3 种持久化方式的主要区别在于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>同步 AOF 文件的时机（刷盘）**。</p>
<p>为了兼顾数据和写入性能，可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p>从 Redis 7.0.0 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p>
<ul>
<li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li>
<li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li>
<li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>
</ul>
<h4 id="AOF-为什么是在执行完命令之后记录日志？"><a href="#AOF-为什么是在执行完命令之后记录日志？" class="headerlink" title="AOF 为什么是在执行完命令之后记录日志？"></a>AOF 为什么是在执行完命令之后记录日志？</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039078.png" alt="AOF 记录日志过程">AOF 记录日志过程</p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<h4 id="AOF-重写了解吗？"><a href="#AOF-重写了解吗？" class="headerlink" title="AOF 重写了解吗？"></a>AOF 重写了解吗？</h4><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039079.png" alt="AOF 重写">AOF 重写<br>AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<p>由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。</p>
<p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p>开启 AOF 重写功能，可以调用 <code>BGREWRITEAOF</code> 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>auto-aof-rewrite-min-size</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;</span><br><span class="line">* ```js </span><br><span class="line">auto-aof-rewrite-percentage</span><br></pre></td></tr></table></figure>
<p>：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</p>
<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>
<h4 id="AOF-校验机制了解吗？"><a href="#AOF-校验机制了解吗？" class="headerlink" title="AOF 校验机制了解吗？"></a>AOF 校验机制了解吗？</h4><p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>
<h4 id="Redis-4-0-对于持久化机制做了什么优化？"><a href="#Redis-4-0-对于持久化机制做了什么优化？" class="headerlink" title="Redis 4.0 对于持久化机制做了什么优化？"></a>Redis 4.0 对于持久化机制做了什么优化？</h4><p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h4 id="如何选择-RDB-和-AOF？"><a href="#如何选择-RDB-和-AOF？" class="headerlink" title="如何选择 RDB 和 AOF？"></a>如何选择 RDB 和 AOF？</h4><p><strong>RDB 比 AOF 优秀的地方</strong>：</p>
<ul>
<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p><strong>AOF 比 RDB 优秀的地方</strong>：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">FLUSHALL</span></span><br></pre></td></tr></table></figure>
<p>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</p>
<p><strong>综上</strong>：</p>
<ul>
<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>
<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>
<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>
</ul>
<h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><h4 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h4><p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<h4 id="如何使用-Redis-事务？"><a href="#如何使用-Redis-事务？" class="headerlink" title="如何使用 Redis 事务？"></a>如何使用 Redis 事务？</h4><p>Redis 可以通过 **</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">MULTI</span></span><br></pre></td></tr></table></figure>
<p>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">EXEC</span></span><br></pre></td></tr></table></figure>
<p>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DISCARD</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">WATCH</span></span><br></pre></td></tr></table></figure>
<p>** 等命令来实现事务(Transaction)功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">MULTI</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line">&gt; <span class="variable constant_">GET</span> <span class="variable constant_">PROJECT</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line">&gt; <span class="variable constant_">EXEC</span></span><br><span class="line"><span class="number">1</span>) <span class="variable constant_">OK</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;JavaGuide&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个过程是这样的：</p>
<ol>
<li>开始事务（</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">MULTI</span></span><br></pre></td></tr></table></figure>
<p>）；</p>
<ol>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>
<li>执行事务(</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">EXEC</span></span><br></pre></td></tr></table></figure>
<p>)。</p>
<p>你也可以通过 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DISCARD</span></span><br></pre></td></tr></table></figure>
<p>open in new window<a target="_blank" rel="noopener" href="https://redis.io/commands/discard">https://redis.io/commands/discard</a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">MULTI</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line">&gt; <span class="variable constant_">GET</span> <span class="variable constant_">PROJECT</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line">&gt; <span class="variable constant_">DISCARD</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br></pre></td></tr></table></figure>

<p>你可以通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">WATCH</span></span><br></pre></td></tr></table></figure>
<p>open in new window<a target="_blank" rel="noopener" href="https://redis.io/commands/watch">https://redis.io/commands/watch</a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端&#x2F;Session</strong> 修改的话，整个事务都不会被执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 客户端 <span class="number">1</span></span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;RustGuide&quot;</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">WATCH</span> <span class="variable constant_">PROJECT</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">MULTI</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line"></span><br><span class="line"># 客户端 <span class="number">2</span></span><br><span class="line"># 在客户端 <span class="number">1</span> 执行 <span class="variable constant_">EXEC</span> 命令提交事务之前修改 <span class="variable constant_">PROJECT</span> 的值</span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;GoGuide&quot;</span></span><br><span class="line"></span><br><span class="line"># 客户端 <span class="number">1</span></span><br><span class="line"># 修改失败，因为 <span class="variable constant_">PROJECT</span> 的值被客户端<span class="number">2</span>修改了</span><br><span class="line">&gt; <span class="variable constant_">EXEC</span></span><br><span class="line">(nil)</span><br><span class="line">&gt; <span class="variable constant_">GET</span> <span class="variable constant_">PROJECT</span></span><br><span class="line"><span class="string">&quot;GoGuide&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的</p>
<p>事务内部修改 WATCH 监视的 Key：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">WATCH</span> <span class="variable constant_">PROJECT</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">MULTI</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide1&quot;</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide2&quot;</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide3&quot;</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line">&gt; <span class="variable constant_">EXEC</span></span><br><span class="line"><span class="number">1</span>) <span class="variable constant_">OK</span></span><br><span class="line"><span class="number">2</span>) <span class="variable constant_">OK</span></span><br><span class="line"><span class="number">3</span>) <span class="variable constant_">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">GET</span> <span class="variable constant_">PROJECT</span></span><br><span class="line"><span class="string">&quot;JavaGuide3&quot;</span></span><br></pre></td></tr></table></figure>

<p>事务外部修改 WATCH 监视的 Key：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">WATCH</span> <span class="variable constant_">PROJECT</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">SET</span> <span class="variable constant_">PROJECT</span> <span class="string">&quot;JavaGuide2&quot;</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">MULTI</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line">&gt; <span class="variable constant_">GET</span> <span class="variable constant_">USER</span></span><br><span class="line"><span class="variable constant_">QUEUED</span></span><br><span class="line">&gt; <span class="variable constant_">EXEC</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h4 id="Redis-事务支持原子性吗？"><a href="#Redis-事务支持原子性吗？" class="headerlink" title="Redis 事务支持原子性吗？"></a>Redis 事务支持原子性吗？</h4><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。</p>
<h4 id="Redis-事务支持持久性吗？"><a href="#Redis-事务支持持久性吗？" class="headerlink" title="Redis 事务支持持久性吗？"></a>Redis 事务支持持久性吗？</h4><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p>
<p>因此，Redis 事务的持久性也是没办法保证的。</p>
<h4 id="如何解决-Redis-事务的缺陷？"><a href="#如何解决-Redis-事务的缺陷？" class="headerlink" title="如何解决 Redis 事务的缺陷？"></a>如何解决 Redis 事务的缺陷？</h4><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>
<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>
<p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>
<h3 id="Redis-性能优化"><a href="#Redis-性能优化" class="headerlink" title="Redis 性能优化"></a>Redis 性能优化</h3><h4 id="使用批量操作减少网络传输"><a href="#使用批量操作减少网络传输" class="headerlink" title="使用批量操作减少网络传输"></a>使用批量操作减少网络传输</h4><p>一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p>
<p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p>
<p>另外，除了能减少 RTT 之外，发送一次命令的 socket I&#x2F;O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I&#x2F;O 成本。</p>
<h5 id="原生批量操作命令"><a href="#原生批量操作命令" class="headerlink" title="原生批量操作命令"></a>原生批量操作命令</h5><p>Redis 中有一些原生支持批量操作的命令，比如：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>MGET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(获取一个或多个指定 key 的值)、</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">MSET</span><br></pre></td></tr></table></figure>
<p>(设置一个或多个指定 key 的值)、</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>HMGET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(获取指定哈希表中一个或者多个指定字段的值)、</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">HMSET</span><br></pre></td></tr></table></figure>
<p>(同时将一个或多个 field-value 对设置到指定哈希表中)、</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>SADD</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（向指定集合添加一个或多个元素）</span><br><span class="line"></span><br><span class="line">不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 `MGET` 无法保证所有的 key 都在同一个 **hash slot**（哈希槽）上，`MGET`可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</span><br><span class="line"></span><br><span class="line">整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</span><br><span class="line"></span><br><span class="line">1. 找到 key 对应的所有 hash slot；</span><br><span class="line">1. 分别向对应的 Redis 节点发起</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">MGET</span><br></pre></td></tr></table></figure>
<p>请求获取数据；</p>
<ol>
<li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li>
</ol>
<p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。<br>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p>
<h5 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h5><p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p>
<p>与<code>MGET</code>、<code>MSET</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p>
<p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p>
<ul>
<li>原生批量操作命令是原子操作，pipeline 是非原子操作。</li>
<li>pipeline 可以打包不同的命令，原生批量操作命令不可以。</li>
<li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li>
</ul>
<p>顺带补充一下 pipeline 和 Redis 事务的对比：</p>
<ul>
<li>事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。</li>
<li>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。<br>事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。</li>
</ul>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039080.png" alt="img"></p>
<p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p>
<h5 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h5><p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>
<p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>
<p>不过， Lua 脚本依然存在下面这些缺陷：</p>
<ul>
<li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li>
<li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li>
</ul>
<h4 id="大量-key-集中过期问题"><a href="#大量-key-集中过期问题" class="headerlink" title="大量 key 集中过期问题"></a>大量 key 集中过期问题</h4><p>我在前面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 策略。</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p><strong>如何解决呢？</strong> 下面是两种常见的方法：</p>
<ol>
<li>给 key 设置随机过期时间。</li>
<li>开启 lazy-free（惰性删除&#x2F;延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ol>
<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>
<h4 id="Redis-bigkey（大-Key）"><a href="#Redis-bigkey（大-Key）" class="headerlink" title="Redis bigkey（大 Key）"></a>Redis bigkey（大 Key）</h4><h5 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="什么是 bigkey？"></a>什么是 bigkey？</h5><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<h5 id="bigkey-有什么危害？"><a href="#bigkey-有什么危害？" class="headerlink" title="bigkey 有什么危害？"></a>bigkey 有什么危害？</h5><p>bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。</p>
<h5 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="如何发现 bigkey？"></a>如何发现 bigkey？</h5><p>**1、使用 Redis 自带的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--bigkeys</span><br></pre></td></tr></table></figure>
<p>参数来查找。**</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># redis-cli -p <span class="number">6379</span> --bigkeys</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Scanning</span> the entire keyspace to find biggest keys <span class="keyword">as</span> well <span class="keyword">as</span></span><br><span class="line"># average sizes per key type.  <span class="title class_">You</span> can use -i <span class="number">0.1</span> to sleep <span class="number">0.1</span> sec</span><br><span class="line"># per <span class="number">100</span> <span class="variable constant_">SCAN</span> commands (not usually needed).</span><br><span class="line"></span><br><span class="line">[<span class="number">00</span><span class="number">.00</span>%] <span class="title class_">Biggest</span> string found so far <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> <span class="keyword">with</span> <span class="number">4437</span> bytes</span><br><span class="line">[<span class="number">00</span><span class="number">.00</span>%] <span class="title class_">Biggest</span> list   found so far <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> <span class="keyword">with</span> <span class="number">17</span> items</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sampled</span> <span class="number">5</span> keys <span class="keyword">in</span> the keyspace!</span><br><span class="line"><span class="title class_">Total</span> key length <span class="keyword">in</span> bytes is <span class="number">264</span> (avg len <span class="number">52.80</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Biggest</span>   list found <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> has <span class="number">17</span> items</span><br><span class="line"><span class="title class_">Biggest</span> string found <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has <span class="number">4437</span> bytes</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> lists <span class="keyword">with</span> <span class="number">17</span> items (<span class="number">20.00</span>% <span class="keyword">of</span> keys, avg size <span class="number">17.00</span>)</span><br><span class="line"><span class="number">0</span> hashs <span class="keyword">with</span> <span class="number">0</span> fields (<span class="number">00</span><span class="number">.00</span>% <span class="keyword">of</span> keys, avg size <span class="number">0.00</span>)</span><br><span class="line"><span class="number">4</span> strings <span class="keyword">with</span> <span class="number">4831</span> bytes (<span class="number">80.00</span>% <span class="keyword">of</span> keys, avg size <span class="number">1207.75</span>)</span><br><span class="line"><span class="number">0</span> streams <span class="keyword">with</span> <span class="number">0</span> entries (<span class="number">00</span><span class="number">.00</span>% <span class="keyword">of</span> keys, avg size <span class="number">0.00</span>)</span><br><span class="line"><span class="number">0</span> sets <span class="keyword">with</span> <span class="number">0</span> members (<span class="number">00</span><span class="number">.00</span>% <span class="keyword">of</span> keys, avg size <span class="number">0.00</span>)</span><br><span class="line"><span class="number">0</span> zsets <span class="keyword">with</span> <span class="number">0</span> members (<span class="number">00</span><span class="number">.00</span>% <span class="keyword">of</span> keys, avg size <span class="number">0.00</span></span><br></pre></td></tr></table></figure>

<p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。</p>
<p>在线上执行该命令时，为了降低对 Redis 的影响，需要指定 <code>-i</code> 参数控制扫描的频率。<code>redis-cli -p 6379 --bigkeys -i 3</code> 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。</p>
<p><strong>2、借助开源工具分析 RDB 文件。</strong></p>
<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>
<p>网上有现成的代码&#x2F;工具可以直接拿来使用：</p>
<ul>
<li>redis-rdb-toolsopen in new window<a target="_blank" rel="noopener" href="https://github.com/sripathikrishnan/redis-rdb-tools%EF%BC%9APython">https://github.com/sripathikrishnan/redis-rdb-tools：Python</a> 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li>rdb_bigkeysopen in new window<a target="_blank" rel="noopener" href="https://github.com/weiyanwei412/rdb_bigkeys">https://github.com/weiyanwei412/rdb_bigkeys</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
<p><strong>3、借助公有云的 Redis 分析服务。</strong></p>
<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>
<p>这里以阿里云 Redis 为例说明，它支持 bigkey 实时分析、发现，文档地址：<a target="_blank" rel="noopener" href="https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-featureopen">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-featureopen</a> in new window<a target="_blank" rel="noopener" href="https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature</a> 。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039081.png" alt="阿里云Key分析"></p>
<h5 id="如何处理-bigkey？"><a href="#如何处理-bigkey？" class="headerlink" title="如何处理 bigkey？"></a>如何处理 bigkey？</h5><p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>
<ul>
<li><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。</li>
<li><strong>手动清理</strong>：Redis 4.0+ 可以使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">UNLINK</span></span><br></pre></td></tr></table></figure>
<p>命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SCAN</span></span><br></pre></td></tr></table></figure>
<p>命令结合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DEL</span></span><br></pre></td></tr></table></figure>
<p>命令来分批次删除。</p>
<ul>
<li><strong>采用合适的数据结构</strong>：比如使用 HyperLogLog 统计页面 UV。</li>
<li><strong>开启 lazy-free（惰性删除&#x2F;延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ul>
<h4 id="Redis-hotkey（热-Key）"><a href="#Redis-hotkey（热-Key）" class="headerlink" title="Redis hotkey（热 Key）"></a>Redis hotkey（热 Key）</h4><h5 id="什么是-hotkey？"><a href="#什么是-hotkey？" class="headerlink" title="什么是 hotkey？"></a>什么是 hotkey？</h5><p>简单来说，如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p>
<p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>
<h5 id="hotkey-有什么危害？"><a href="#hotkey-有什么危害？" class="headerlink" title="hotkey 有什么危害？"></a>hotkey 有什么危害？</h5><p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p>
<p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>
<h5 id="如何发现-hotkey？"><a href="#如何发现-hotkey？" class="headerlink" title="如何发现 hotkey？"></a>如何发现 hotkey？</h5><p>**1、使用 Redis 自带的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--hotkeys</span><br></pre></td></tr></table></figure>
<p>参数来查找。**</p>
<p>Redis 4.0.3 版本中新增了 <code>hotkeys</code> 参数，该参数能够返回所有 key 的被访问次数。</p>
<p>使用该方案的前提条件是 Redis Server 的 <code>maxmemory-policy</code> 参数设置为 LFU 算法，不然就会出现如下所示的错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># redis-cli -p <span class="number">6379</span> --hotkeys</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Scanning</span> the entire keyspace to find hot keys <span class="keyword">as</span> well <span class="keyword">as</span></span><br><span class="line"># average sizes per key type.  <span class="title class_">You</span> can use -i <span class="number">0.1</span> to sleep <span class="number">0.1</span> sec</span><br><span class="line"># per <span class="number">100</span> <span class="variable constant_">SCAN</span> commands (not usually needed).</span><br><span class="line"></span><br><span class="line"><span class="title class_">Error</span>: <span class="variable constant_">ERR</span> <span class="title class_">An</span> <span class="variable constant_">LFU</span> maxmemory policy is not selected, access frequency not tracked. <span class="title class_">Please</span> note that when switching between policies at runtime <span class="variable constant_">LRU</span> and <span class="variable constant_">LFU</span> data will take some time to adjust.</span><br></pre></td></tr></table></figure>

<p>Redis 中有两种 LFU 算法：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="property">db</span>[i].<span class="property">expires</span></span><br></pre></td></tr></table></figure>
<p>）中挑选最不经常使用的数据淘汰。</p>
<ol>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
<p>以下是配置文件 <code>redis.conf</code> 中的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 volatile-lfu 策略</span><br><span class="line">maxmemory-policy volatile-lfu</span><br><span class="line"></span><br><span class="line"># 或者使用 allkeys-lfu 策略</span><br><span class="line">maxmemory-policy allkeys-lfu</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>hotkeys</code> 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p>
<p>**2、使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">MONITOR</span></span><br></pre></td></tr></table></figure>
<p>命令。**</p>
<p><code>MONITOR</code> 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。</p>
<p>由于该命令对 Redis 性能的影响比较大，因此禁止长时间开启 <code>MONITOR</code>（生产环境中建议谨慎使用该命令）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">MONITOR</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br><span class="line"><span class="number">1683638260.637378</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61516</span>] <span class="string">&quot;ping&quot;</span></span><br><span class="line"><span class="number">1683638267.144236</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61518</span>] <span class="string">&quot;smembers&quot;</span> <span class="string">&quot;mySet&quot;</span></span><br><span class="line"><span class="number">1683638268.941863</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61518</span>] <span class="string">&quot;smembers&quot;</span> <span class="string">&quot;mySet&quot;</span></span><br><span class="line"><span class="number">1683638269.551671</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61518</span>] <span class="string">&quot;smembers&quot;</span> <span class="string">&quot;mySet&quot;</span></span><br><span class="line"><span class="number">1683638270.646256</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61516</span>] <span class="string">&quot;ping&quot;</span></span><br><span class="line"><span class="number">1683638270.849551</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61518</span>] <span class="string">&quot;smembers&quot;</span> <span class="string">&quot;mySet&quot;</span></span><br><span class="line"><span class="number">1683638271.926945</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61518</span>] <span class="string">&quot;smembers&quot;</span> <span class="string">&quot;mySet&quot;</span></span><br><span class="line"><span class="number">1683638274.276599</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61518</span>] <span class="string">&quot;smembers&quot;</span> <span class="string">&quot;mySet2&quot;</span></span><br><span class="line"><span class="number">1683638276.327234</span> [<span class="number">0</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">61518</span>] <span class="string">&quot;smembers&quot;</span> <span class="string">&quot;mySet&quot;</span></span><br></pre></td></tr></table></figure>

<p>在发生紧急情况时，我们可以选择在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，在关闭 <code>MONITOR</code> 命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。</p>
<p><strong>3、借助开源项目。</strong></p>
<p>京东零售的 hotkeyopen in new window<a target="_blank" rel="noopener" href="https://gitee.com/jd-platform-opensource/hotkey">https://gitee.com/jd-platform-opensource/hotkey</a> 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039082.png" alt="京东零售开源的 hotkey"></p>
<p><strong>4、根据业务情况提前预估。</strong></p>
<p>可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。</p>
<p><strong>5、业务代码中记录分析。</strong></p>
<p>在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。</p>
<p><strong>6、借助公有云的 Redis 分析服务。</strong></p>
<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>
<h5 id="如何解决-hotkey？"><a href="#如何解决-hotkey？" class="headerlink" title="如何解决 hotkey？"></a>如何解决 hotkey？</h5><p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>
<ul>
<li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li>
<li><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li>
<li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li>
</ul>
<p>除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。</p>
<p>这里以阿里云 Redis 为例说明，它支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039083.png" alt="通过阿里云的Proxy Query Cache优化热点Key问题"></p>
<h4 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h4><h5 id="为什么会有慢查询命令？"><a href="#为什么会有慢查询命令？" class="headerlink" title="为什么会有慢查询命令？"></a>为什么会有慢查询命令？</h5><p>我们知道一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p>
<p>Redis 为什么会有慢查询命令呢？</p>
<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>KEYS *</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：会返回所有符合规则的 key。</span><br><span class="line">* ```js </span><br><span class="line">HGETALL</span><br></pre></td></tr></table></figure>
<p>：会返回一个 Hash 中所有的键值对。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>LRANGE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：会返回 List 中指定范围内的元素。</span><br><span class="line">* ```js </span><br><span class="line">SMEMBERS</span><br></pre></td></tr></table></figure>
<p>：返回 Set 中的所有元素。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>SINTER</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">SUNION</span><br></pre></td></tr></table></figure>
<p>&#x2F;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SDIFF</span></span><br></pre></td></tr></table></figure>
<p>：计算多个 Set 的交集&#x2F;并集&#x2F;差集。</p>
<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>
<p>除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>ZRANGE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">ZREVRANGE</span><br></pre></td></tr></table></figure>
<p>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>ZREMRANGEBYRANK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">ZREMRANGEBYSCORE</span><br></pre></td></tr></table></figure>
<p>：移除 Sorted Set 中指定排名范围&#x2F;指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</p>
<h5 id="如何找到慢查询命令？"><a href="#如何找到慢查询命令？" class="headerlink" title="如何找到慢查询命令？"></a>如何找到慢查询命令？</h5><p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p>
<p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p>
<p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p>
<p><code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>的默认配置如下(可以自行修改)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="title class_">The</span> following time is expressed <span class="keyword">in</span> microseconds, so <span class="number">1000000</span> is equivalent</span><br><span class="line"># to one second. <span class="title class_">Note</span> that a negative number disables the slow log, <span class="keyword">while</span></span><br><span class="line"># a value <span class="keyword">of</span> zero forces the logging <span class="keyword">of</span> every command.</span><br><span class="line">slowlog-log-slower-than <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"># <span class="title class_">There</span> is no limit to <span class="variable language_">this</span> length. <span class="title class_">Just</span> be aware that it will consume memory.</span><br><span class="line"># <span class="title class_">You</span> can reclaim memory used by the slow log <span class="keyword">with</span> <span class="variable constant_">SLOWLOG</span> <span class="variable constant_">RESET</span>.</span><br><span class="line">slowlog-max-len <span class="number">128</span></span><br></pre></td></tr></table></figure>

<p>除了修改配置文件之外，你也可以直接通过 <code>CONFIG</code> 命令直接设置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 命令执行耗时超过 <span class="number">10000</span> 微妙（即<span class="number">10</span>毫秒）就会被记录</span><br><span class="line"><span class="variable constant_">CONFIG</span> <span class="variable constant_">SET</span> slowlog-log-slower-than <span class="number">10000</span></span><br><span class="line"># 只保留最近 <span class="number">128</span> 条耗时命令</span><br><span class="line"><span class="variable constant_">CONFIG</span> <span class="variable constant_">SET</span> slowlog-max-len <span class="number">128</span></span><br></pre></td></tr></table></figure>

<p>获取慢查询日志的内容很简单，直接使用<code>SLOWLOG GET</code> 命令即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">SLOWLOG</span> <span class="variable constant_">GET</span> #慢日志查询</span><br><span class="line"> <span class="number">1</span>) <span class="number">1</span>) (integer) <span class="number">5</span></span><br><span class="line">   <span class="number">2</span>) (integer) <span class="number">1684326682</span></span><br><span class="line">   <span class="number">3</span>) (integer) <span class="number">12000</span></span><br><span class="line">   <span class="number">4</span>) <span class="number">1</span>) <span class="string">&quot;KEYS&quot;</span></span><br><span class="line">      <span class="number">2</span>) <span class="string">&quot;*&quot;</span></span><br><span class="line">   <span class="number">5</span>) <span class="string">&quot;172.17.0.1:61152&quot;</span></span><br><span class="line">   <span class="number">6</span>) <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>慢查询日志中的每个条目都由以下六个值组成：</p>
<ol>
<li>唯一渐进的日志标识符。</li>
<li>处理记录命令的 Unix 时间戳。</li>
<li>执行所需的时间量，以微秒为单位。</li>
<li>组成命令参数的数组。</li>
<li>客户端 IP 地址和端口。</li>
<li>客户端名称。</li>
</ol>
<p><code>SLOWLOG GET</code> 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p>
<p>下面是其他比较常用的慢查询相关的命令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 返回慢查询命令的数量</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">SLOWLOG</span> <span class="variable constant_">LEN</span></span><br><span class="line">(integer) <span class="number">128</span></span><br><span class="line"># 清空慢查询命令</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">SLOWLOG</span> <span class="variable constant_">RESET</span></span><br><span class="line"><span class="variable constant_">OK</span></span><br></pre></td></tr></table></figure>

<h4 id="Redis内存碎片"><a href="#Redis内存碎片" class="headerlink" title="Redis内存碎片"></a>Redis内存碎片</h4><p>什么是内存碎片?</p>
<p>你可以将内存碎片简单地理解为那些不可用的空闲内存。</p>
<p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039084.png" alt="内存碎片"></p>
<p>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</p>
<p>为什么会有 Redis 内存碎片?</p>
<p>Redis 内存碎片产生比较常见的 2 个原因：</p>
<p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></p>
<p>Redis 使用 <code>zmalloc</code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 <code>size</code> 大小的内存之外，还会多分配 <code>PREFIX_SIZE</code> 大小的内存。</p>
<p>另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 jemallocopen in new window<a target="_blank" rel="noopener" href="https://github.com/jemalloc/jemalloc%EF%BC%8C%E8%80%8C">https://github.com/jemalloc/jemalloc，而</a> jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节…）来分配内存的。jemalloc 划分的内存单元如下图所示：</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039085.png" alt="jemalloc 内存单元示意图"></p>
<p>当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。</p>
<p><strong>2、频繁修改 Redis 中的数据也会产生内存碎片。</strong></p>
<p>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p>
<p>如何查看 Redis 内存碎片的信息？</p>
<p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息。</p>
<p>Redis 内存碎片率的计算公式：<code>mem_fragmentation_ratio</code> （内存碎片率）&#x3D; <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)&#x2F; <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>
<p>也就是说，<code>mem_fragmentation_ratio</code> （内存碎片率）的值越大代表内存碎片率越严重。</p>
<p>一定不要误认为<code>used_memory_rss</code> 减去 <code>used_memory</code>值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>
<p>很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。</p>
<p>通常情况下，我们认为 <code>mem_fragmentation_ratio &gt; 1.5</code> 的话才需要清理内存碎片。 <code>mem_fragmentation_ratio &gt; 1.5</code> 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。</p>
<p>如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-cli -p <span class="number">6379</span> info | grep mem_fragmentation_ratio</span><br></pre></td></tr></table></figure>

<p>另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区open in new window<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/drlDvp7bfq5jt2M5pTqJCw">https://mp.weixin.qq.com/s/drlDvp7bfq5jt2M5pTqJCw</a> 。</p>
<p>如何清理 Redis 内存碎片？</p>
<p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>
<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set activedefrag yes</span><br></pre></td></tr></table></figure>

<p>具体什么时候清理需要通过下面两个参数控制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 内存碎片占用空间达到 500mb 的时候开始清理</span><br><span class="line">config set active-defrag-ignore-bytes 500mb</span><br><span class="line"># 内存碎片率大于 <span class="number">1.5</span> 的时候开始清理</span><br><span class="line">config set active-defrag-threshold-lower <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 内存碎片清理所占用 <span class="variable constant_">CPU</span> 时间的比例不低于 <span class="number">20</span>%</span><br><span class="line">config set active-defrag-cycle-min <span class="number">20</span></span><br><span class="line"># 内存碎片清理所占用 <span class="variable constant_">CPU</span> 时间的比例不高于 <span class="number">50</span>%</span><br><span class="line">config set active-defrag-cycle-max <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</p>
<h3 id="Redis-生产问题（重要）"><a href="#Redis-生产问题（重要）" class="headerlink" title="Redis 生产问题（重要）"></a>Redis 生产问题（重要）</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>什么是缓存穿透？</p>
<p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039086.png" alt="缓存穿透"></p>
<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
<p>有哪些解决办法？</p>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的：<code>表名:列名:主键名:主键值</code> 。</p>
<p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039087.png" alt="加入布隆过滤器之后的缓存处理流程图"></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>布隆过滤器的原理介绍</p>
<p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>Bloom Filter 的简单原理图如下：</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039088.png" alt="Bloom Filter 的简单原理示意图"></p>
<p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。</p>
<p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p>
<p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p>布隆过滤器使用场景</p>
<ol>
<li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，上亿）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤（判断一个邮件地址是否在垃圾邮件列表中）、黑名单功能（判断一个IP地址或手机号码是否在黑名单中）等等。</li>
<li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重、对巨量的 QQ号&#x2F;订单号去重。</li>
</ol>
<p>利用 Google 开源的 Guava 中自带的布隆过滤器</p>
<p>首先我们需要在项目中引入 Guava 的依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>实际使用如下：</p>
<p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line"><span class="title class_">BloomFilter</span>&lt;<span class="title class_">Integer</span>&gt; filter = <span class="title class_">BloomFilter</span>.<span class="title function_">create</span>(</span><br><span class="line">    <span class="title class_">Funnels</span>.<span class="title function_">integerFunnel</span>(),</span><br><span class="line">    <span class="number">1500</span>,</span><br><span class="line">    <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 判断指定元素是否存在</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(filter.<span class="title function_">mightContain</span>(<span class="number">1</span>));</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(filter.<span class="title function_">mightContain</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">filter.<span class="title function_">put</span>(<span class="number">1</span>);</span><br><span class="line">filter.<span class="title function_">put</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(filter.<span class="title function_">mightContain</span>(<span class="number">1</span>));</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(filter.<span class="title function_">mightContain</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>在我们的示例中，当 <code>mightContain()</code> 方法返回 <em>true</em> 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 <em>false</em> 时，我们可以 100％确定该元素不存在于过滤器中。</p>
<p><strong>Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。</strong></p>
<p>Redis 中的布隆过滤器</p>
<p>官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module</p>
<p>使用 Docker 安装</p>
<p><strong>具体操作如下：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run -p <span class="number">6379</span>:<span class="number">6379</span> --name redis-redisbloom redislabs/<span class="attr">rebloom</span>:latest</span><br><span class="line">➜  ~ docker exec -it redis-redisbloom bash</span><br><span class="line">root@21396<span class="attr">d02c252</span>:/data# redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：当前rebloom镜像已经被废弃，官方推荐使用redis-stack<a target="_blank" rel="noopener" href="https://hub.docker.com/r/redis/redis-stack">https://hub.docker.com/r/redis/redis-stack</a></strong></p>
<p>常用命令一览</p>
<p>注意：key : 布隆过滤器的名称，item : 添加的元素。</p>
<ol>
<li>**<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">ADD</span></span><br></pre></td></tr></table></figure>
**：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">ADD</span> &#123;key&#125; &#123;item&#125;</span><br></pre></td></tr></table></figure>
<p>。</p>
<ol>
<li>**<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">MADD</span></span><br></pre></td></tr></table></figure>
** : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">ADD</span></span><br></pre></td></tr></table></figure>
<p>与之相同，只不过它允许多个输入并返回多个值。格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">MADD</span> &#123;key&#125; &#123;item&#125; [item ...]</span><br></pre></td></tr></table></figure>
<p>。</p>
<ol>
<li>**<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">EXISTS</span></span><br></pre></td></tr></table></figure>
** : 确定元素是否在布隆过滤器中存在。格式：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">EXISTS</span> &#123;key&#125; &#123;item&#125;</span><br></pre></td></tr></table></figure>
<p>。</p>
<ol>
<li>**<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">MEXISTS</span></span><br></pre></td></tr></table></figure>
**：确定一个或者多个元素是否在布隆过滤器中存在格式：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BF</span>.<span class="property">MEXISTS</span> &#123;key&#125; &#123;item&#125; [item ...]</span><br></pre></td></tr></table></figure>
<p>。</p>
<p>另外， <code>BF.RESERVE</code> 命令需要单独介绍一下：</p>
<p>这个命令的格式如下：</p>
<p><code>BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION expansion]</code> 。</p>
<p>下面简单介绍一下每个参数的具体含义：</p>
<ol>
<li>key：布隆过滤器的名称</li>
<li>error_rate : 期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。</li>
<li>capacity: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li>
</ol>
<p>可选参数：</p>
<ul>
<li>expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expansion</span><br></pre></td></tr></table></figure>
<p>。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。</p>
<p>实际使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">BF</span>.<span class="property">ADD</span> myFilter java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">BF</span>.<span class="property">ADD</span> myFilter javaguide</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">BF</span>.<span class="property">EXISTS</span> myFilter java</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">BF</span>.<span class="property">EXISTS</span> myFilter javaguide</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="variable constant_">BF</span>.<span class="property">EXISTS</span> myFilter github</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>什么是缓存击穿？</p>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039089.png" alt="缓存击穿"></p>
<p>有哪些解决办法？</p>
<ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
<h4 id="缓存穿透和缓存击穿有什么区别？"><a href="#缓存穿透和缓存击穿有什么区别？" class="headerlink" title="缓存穿透和缓存击穿有什么区别？"></a>缓存穿透和缓存击穿有什么区别？</h4><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>什么是缓存雪崩？</p>
<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>
<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039090.png" alt="缓存雪崩"></p>
<p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<p>有哪些解决办法？</p>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效（不太推荐，实用性太差）。</li>
<li>设置二级缓存。</li>
</ol>
<p>缓存雪崩和缓存击穿有什么区别？</p>
<p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p>
<h4 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h4><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h4 id="哪些情况可能会导致-Redis-阻塞？"><a href="#哪些情况可能会导致-Redis-阻塞？" class="headerlink" title="哪些情况可能会导致 Redis 阻塞？"></a>哪些情况可能会导致 Redis 阻塞？</h4><p>O(n) 命令</p>
<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>KEYS *</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：会返回所有符合规则的 key。</span><br><span class="line">* ```js </span><br><span class="line">HGETALL</span><br></pre></td></tr></table></figure>
<p>：会返回一个 Hash 中所有的键值对。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>LRANGE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">：会返回 List 中指定范围内的元素。</span><br><span class="line">* ```js </span><br><span class="line">SMEMBERS</span><br></pre></td></tr></table></figure>
<p>：返回 Set 中的所有元素。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>SINTER</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">SUNION</span><br></pre></td></tr></table></figure>
<p>&#x2F;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SDIFF</span></span><br></pre></td></tr></table></figure>
<p>：计算多个 Set 的交集&#x2F;并集&#x2F;差集。</p>
<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>
<p>除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>ZRANGE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">ZREVRANGE</span><br></pre></td></tr></table></figure>
<p>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>ZREMRANGEBYRANK</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"></span><br><span class="line">```js </span><br><span class="line">ZREMRANGEBYSCORE</span><br></pre></td></tr></table></figure>
<p>：移除 Sorted Set 中指定排名范围&#x2F;指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</p>
<p>SAVE 创建 RDB 快照</p>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><pre><code class="js">
</code></pre>
</li>
</ul>
<p>save</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">: 同步保存操作，会阻塞 Redis 主线程；</span><br><span class="line">* ```js </span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure>
<p>: fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</p>
<p>默认情况下，Redis 默认配置会使用 <code>bgsave</code> 命令。如果手动使用 <code>save</code> 命令生成 RDB 快照文件的话，就会阻塞主线程。</p>
<p>AOF</p>
<p>AOF 日志记录阻塞</p>
<p>Redis AOF 持久化机制是在执行完命令之后再记录日志，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。</p>
<p><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/img/202403142039091.png" alt="AOF 记录日志过程"></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li><strong>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）</strong>。</li>
</ul>
<p>AOF 刷盘阻塞</p>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<p>1. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always</span><br></pre></td></tr></table></figure>
<p>：主线程调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>执行写操作后，后台线程（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof_fsync</span><br></pre></td></tr></table></figure>
<p>线程）立即会调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>函数同步 AOF 文件（刷盘），</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>完成后线程返回，这样会严重降低 Redis 的性能（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>）。</p>
<p>1. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>
<p>：主线程调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>执行写操作后立即返回，由后台线程（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof_fsync</span><br></pre></td></tr></table></figure>
<p>线程）每秒钟调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>函数（系统调用）同步一次 AOF 文件（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>间隔为 1 秒）</p>
<p>1. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync no</span><br></pre></td></tr></table></figure>
<p>：主线程调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write</span><br></pre></td></tr></table></figure>
<p>但不</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsync</span><br></pre></td></tr></table></figure>
<p>的时机由操作系统决定）。</p>
<p>当后台线程（ <code>aof_fsync</code> 线程）调用 <code>fsync</code> 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。<code>fsync</code> 完成后，主线程执行 <code>write</code> 才能成功返回。</p>
<p>AOF 重写阻塞</p>
<ol>
<li>fork 出一条子线程来将文件重写，在执行</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BGREWRITEAOF</span></span><br></pre></td></tr></table></figure>
<p>命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</p>
<ol>
<li>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li>
</ol>
<p>阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p>
<p>大 Key</p>
<p>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<p>大 key 造成的阻塞问题如下：</p>
<ul>
<li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li>引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li>阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
</ul>
<p>查找大 key</p>
<p>当我们在使用 Redis 自带的 <code>--bigkeys</code> 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会<strong>阻塞</strong>主节点。</p>
<ul>
<li>我们还可以使用 SCAN 命令来查找大 key；</li>
<li>通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：</li>
<li><ul>
<li>redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
</ul>
</li>
<li>rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
<p>删除大 key</p>
<p>删除操作的本质是要释放键值对占用的内存空间。</p>
<p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞</strong>当前释放内存的应用程序。</p>
<p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>
<p>删除大 key 时建议采用分批次删除和异步删除的方式进行。</p>
<p>清空数据库</p>
<p>清空数据库和上面 bigkey 删除也是同样道理，<code>flushdb</code>、<code>flushall</code> 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。</p>
<p>集群扩容</p>
<p>Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。</p>
<p>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。</p>
<p>执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p>
<p>Swap（内存交换）</p>
<p><strong>什么是 Swap？</strong> Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。</p>
<p>Swap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘的读写速度差几个数量级，会导致发生交换后的 Redis 性能急剧下降。</p>
<p>识别 Redis 发生 Swap 的检查方法如下：</p>
<p>1、查询 Redis 进程号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reids-cli -p <span class="number">6383</span> info server | grep process_id</span><br><span class="line"><span class="attr">process_id</span>: <span class="number">4476</span></span><br></pre></td></tr></table></figure>

<p>2、根据进程号查询内存交换信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/<span class="number">4476</span>/smaps | grep <span class="title class_">Swap</span></span><br><span class="line"><span class="title class_">Swap</span>: 0kB</span><br><span class="line"><span class="title class_">Swap</span>: 0kB</span><br><span class="line"><span class="title class_">Swap</span>: 4kB</span><br><span class="line"><span class="title class_">Swap</span>: 0kB</span><br><span class="line"><span class="title class_">Swap</span>: 0kB</span><br></pre></td></tr></table></figure>

<p>如果交换量都是 0KB 或者个别的是 4KB，则正常。</p>
<p>预防内存交换的方法：</p>
<ul>
<li>保证机器充足的可用内存</li>
<li>确保所有 Redis 实例设置最大可用内存(maxmemory)，防止极端情况 Redis 内存不可控的增长</li>
<li>降低系统使用 swap 优先级，如</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">10</span> &gt; <span class="regexp">/proc/</span>sys/vm/swappiness</span><br></pre></td></tr></table></figure>

<p>CPU 竞争</p>
<p>Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</p>
<p>可以通过<code>reids-cli --stat</code>获取当前 Redis 使用情况。通过<code>top</code>命令获取进程对 CPU 的利用率等信息 通过<code>info commandstats</code>统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。</p>
<p>网络问题</p>
<p>连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</p>
<h4 id="Redis-使用规范"><a href="#Redis-使用规范" class="headerlink" title="Redis 使用规范"></a>Redis 使用规范</h4><p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p>
<ol>
<li>使用连接池：避免频繁创建关闭客户端连接。</li>
<li>尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">KEYS</span> *</span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HGETALL</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">LRANGE</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SMEMBERS</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SINTER</span></span><br></pre></td></tr></table></figure>
<p>&#x2F;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SUNION</span></span><br></pre></td></tr></table></figure>
<p>&#x2F;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SDIFF</span></span><br></pre></td></tr></table></figure>
<p>等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HSCAN</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">SSCAN</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">ZSCAN</span></span><br></pre></td></tr></table></figure>
<p>代替。</p>
<ol>
<li>使用批量操作减少网络传输：原生批量操作命令（比如</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">MGET</span></span><br></pre></td></tr></table></figure>
<p>、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">MSET</span></span><br></pre></td></tr></table></figure>
<p>等等）、pipeline、Lua 脚本。</p>
<ol>
<li>尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li>
<li>禁止长时间开启 monitor：对性能影响比较大。</li>
<li>控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li>
</ol>
<h3 id="作者声明"><a href="#作者声明" class="headerlink" title="作者声明"></a>作者声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如有问题，欢迎指正！</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">jhj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/7b25d017.html">http://example.com/post/7b25d017.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">jhj-coding</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/jhj-coding/my-typora-picgo/raw/50195fa8344b061b78a2d7aaafcc2b9d8e7956ad/img/f63f1c575e3c48d9a3f7e4ba9bd460d2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/47eac6e4.html" title="MySQL 基础"><img class="cover" src="https://gitee.com/jhj-coding/my-typora-picgo/raw/50195fa8344b061b78a2d7aaafcc2b9d8e7956ad/img/f63f1c575e3c48d9a3f7e4ba9bd460d2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL 基础</div></div></a></div><div class="next-post pull-right"><a href="/post/9891ebc8.html" title="git基础"><img class="cover" src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/java.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2a06ec4e.html" title="K8s部署任何服务"><img class="cover" src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-09</div><div class="title">K8s部署任何服务</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/avatar1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">jhj</div><div class="author-info__description">努力学习，努力爱你!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">185</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/jhj-coding"><i class="iconfont icon-gitee"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/jhj-coding" target="_blank" title="gitee"><i class="iconfont icon-gitee" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:jhjcoding@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/qq.jpg" target="_blank" title="qq"><i class="fa-brands fa-qq" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">1.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">Redis 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Redis%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是 Redis？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">Redis 为什么这么快？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">分布式缓存常见的技术选型方案有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">说一下 Redis 和 Memcached 的区别和共同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">为什么要用 Redis&#x2F;为什么要用缓存？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">3种常用的缓存读写策略详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-Aside-Pattern%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">Cache Aside Pattern（旁路缓存模式）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-Write-Through-Pattern%EF%BC%88%E8%AF%BB%E5%86%99%E7%A9%BF%E9%80%8F%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">Read&#x2F;Write Through Pattern（读写穿透）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Write-Behind-Pattern%EF%BC%88%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">Write Behind Pattern（异步缓存写入）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">Redis 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%EF%BC%8C%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">Redis 除了做缓存，还能做什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">Redis 可以做消息队列么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">Redis 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-5-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text">Redis 5 种基本数据结构详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">String（字符串）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">List（列表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">Hash（哈希）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">Set（集合）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sorted-Set%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.4.6.</span> <span class="toc-text">Sorted Set（有序集合）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-3-%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.7.</span> <span class="toc-text">Redis 3 种特殊数据结构详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap"><span class="toc-number">1.4.8.</span> <span class="toc-text">Bitmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">1.4.9.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Geospatial-index"><span class="toc-number">1.4.10.</span> <span class="toc-text">Geospatial index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.11.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.4.12.</span> <span class="toc-text">Redis 常用的数据结构有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.4.13.</span> <span class="toc-text">String 的应用场景有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E8%BF%98%E6%98%AF-Hash-%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%A5%BD%E5%91%A2%EF%BC%9F"><span class="toc-number">1.4.14.</span> <span class="toc-text">String 还是 Hash 存储对象数据更好呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.15.</span> <span class="toc-text">String 的底层实现是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8-String-%E8%BF%98%E6%98%AF-Hash-%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A5%BD%E5%91%A2"><span class="toc-number">1.4.16.</span> <span class="toc-text">购物车信息用 String 还是 Hash 存储更好呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">1.4.17.</span> <span class="toc-text">使用 Redis 实现一个排行榜怎么做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.18.</span> <span class="toc-text">Set 的应用场景是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Set-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">1.4.19.</span> <span class="toc-text">使用 Set 实现抽奖系统怎么做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HyperLogLog-%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2-UV-%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">1.4.20.</span> <span class="toc-text">使用 HyperLogLog 统计页面 UV 怎么做？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">Redis持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.5.1.</span> <span class="toc-text">RDB 持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.5.2.</span> <span class="toc-text">AOF 持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-AOF-%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">什么是 AOF 持久化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E5%B7%A5%E4%BD%9C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.5.4.</span> <span class="toc-text">AOF 工作基本流程是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.5.5.</span> <span class="toc-text">AOF 持久化方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%90%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">1.5.6.</span> <span class="toc-text">AOF 为什么是在执行完命令之后记录日志？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">1.5.7.</span> <span class="toc-text">AOF 重写了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">1.5.8.</span> <span class="toc-text">AOF 校验机制了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-4-0-%E5%AF%B9%E4%BA%8E%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.5.9.</span> <span class="toc-text">Redis 4.0 对于持久化机制做了什么优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-RDB-%E5%92%8C-AOF%EF%BC%9F"><span class="toc-number">1.5.10.</span> <span class="toc-text">如何选择 RDB 和 AOF？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.</span> <span class="toc-text">Redis 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Redis-%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是 Redis 事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Redis-%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">如何使用 Redis 事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">Redis 事务支持原子性吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E6%8C%81%E4%B9%85%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">1.6.4.</span> <span class="toc-text">Redis 事务支持持久性吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Redis-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">1.6.5.</span> <span class="toc-text">如何解决 Redis 事务的缺陷？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">Redis 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">1.7.1.</span> <span class="toc-text">使用批量操作减少网络传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">原生批量操作命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pipeline"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">pipeline</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lua-%E8%84%9A%E6%9C%AC"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">Lua 脚本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F-key-%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.2.</span> <span class="toc-text">大量 key 集中过期问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-bigkey%EF%BC%88%E5%A4%A7-Key%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">Redis bigkey（大 Key）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-bigkey%EF%BC%9F"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">什么是 bigkey？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bigkey-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">bigkey 有什么危害？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0-bigkey%EF%BC%9F"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">如何发现 bigkey？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-bigkey%EF%BC%9F"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">如何处理 bigkey？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-hotkey%EF%BC%88%E7%83%AD-Key%EF%BC%89"><span class="toc-number">1.7.4.</span> <span class="toc-text">Redis hotkey（热 Key）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-hotkey%EF%BC%9F"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">什么是 hotkey？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hotkey-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">hotkey 有什么危害？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0-hotkey%EF%BC%9F"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">如何发现 hotkey？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-hotkey%EF%BC%9F"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">如何解决 hotkey？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"><span class="toc-number">1.7.5.</span> <span class="toc-text">慢查询命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">为什么会有慢查询命令？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">如何找到慢查询命令？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">1.7.6.</span> <span class="toc-text">Redis内存碎片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">Redis 生产问题（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.8.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.3.</span> <span class="toc-text">缓存穿透和缓存击穿有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.8.4.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">1.8.5.</span> <span class="toc-text">如何保证缓存和数据库数据的一致性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4-Redis-%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">1.8.6.</span> <span class="toc-text">哪些情况可能会导致 Redis 阻塞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">1.8.7.</span> <span class="toc-text">Redis 使用规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E8%80%85%E5%A3%B0%E6%98%8E"><span class="toc-number">1.9.</span> <span class="toc-text">作者声明</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/167997d8.html" title="jconsole与jvisualvm"><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jconsole与jvisualvm"/></a><div class="content"><a class="title" href="/post/167997d8.html" title="jconsole与jvisualvm">jconsole与jvisualvm</a><time datetime="2023-12-18T09:11:18.000Z" title="发表于 2023-12-18 17:11:18">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/1bfbf0ea.html" title="压力测试详解"><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="压力测试详解"/></a><div class="content"><a class="title" href="/post/1bfbf0ea.html" title="压力测试详解">压力测试详解</a><time datetime="2023-12-18T06:26:44.000Z" title="发表于 2023-12-18 14:26:44">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/7c7fd486.html" title="阿里云部署k8s with kubesphere"><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里云部署k8s with kubesphere"/></a><div class="content"><a class="title" href="/post/7c7fd486.html" title="阿里云部署k8s with kubesphere">阿里云部署k8s with kubesphere</a><time datetime="2023-12-17T09:21:04.000Z" title="发表于 2023-12-17 17:21:04">2023-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2d8b6a16.html" title="性能测试入门"><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="性能测试入门"/></a><div class="content"><a class="title" href="/post/2d8b6a16.html" title="性能测试入门">性能测试入门</a><time datetime="2023-12-10T08:15:58.000Z" title="发表于 2023-12-10 16:15:58">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6998f00a.html" title="冗余设计思想"><img src="https://gitee.com/jhj-coding/my-typora-picgo/raw/master/my-typora-picgo/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="冗余设计思想"/></a><div class="content"><a class="title" href="/post/6998f00a.html" title="冗余设计思想">冗余设计思想</a><time datetime="2023-12-10T08:06:13.000Z" title="发表于 2023-12-10 16:06:13">2023-12-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/jhj-coding/my-typora-picgo/raw/50195fa8344b061b78a2d7aaafcc2b9d8e7956ad/img/f63f1c575e3c48d9a3f7e4ba9bd460d2.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> jhj</div><div class="footer_custom_text">welcome to my blob</div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.jhj-coding.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.jhj-coding.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/custom.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="//code.tidio.co/th7rc6a4lyprr1ddkuejkobcxcttlbcr.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>